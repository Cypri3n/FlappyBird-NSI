'''
Projet Flappy Bird 

On fait jouer automatiquement dix fois 
chaque personnage d'Harry Potter au jeu suivant :
Flappy Bird
A chaque obstacle, la zone de passage est choisie aléatoirement entre 3 zones
L'oiseau tente un passage aléatoire en volant au niveau d'une de ces 3 zones
Si cela concorde, l'oiseau passe et le jeu continu sinon le jeu s'arrête 
50pts si 4 obstacles franchis (score max)
Sinon 4 pts par obstacle franchi
L'oiseau peut passer au max 4 obstacles
On fait une moyenne des 10 résultats pour chaque personnage 
qu'on affiche dans l'ordre croissant


Auteurs :
Cyprien Venard
Paul Di Prizio
Odon Prouille

Version :


Date de dernière révision :


Adresse Github: 
https://github.com/Cypri3n/FlappyBird-NSI/tree/main

'''
# coding: utf-8

#import des modules
from random import randint
import pygame



#définition des constantes


#définitionn des fonctions dans l'ordre d'utlilisation



#Début du programme principal

from pygame.locals import QUIT, VIDEORESIZE, HWSURFACE, DOUBLEBUF, RESIZABLE
#from pygame.sprite import _Group

pygame.init()

clock = pygame.time.Clock()
fps = 60

# Configurer l'écran

screen_widht = 576
screen_height = 1248

# changer les valeurs de l'écran par des variables de préférence
screen = pygame.display.set_mode((screen_widht, screen_height), HWSURFACE | DOUBLEBUF | RESIZABLE)
pygame.display.set_caption("Flappy Bird")

# Images

# l'image avec un RZ (resize) veut tire que je l'ai mise à 200% de sa taille, il suffit de l'enlever
# pour se retrouver avec le format de base

bg_day = pygame.image.load("sprites/background-dayRZ.png").convert()
base = pygame.image.load("sprites/baseRZ.png").convert()
message = pygame.image.load("sprites/messageRZ.png").convert_alpha()

def number_png(index):
    return pygame.image.load(f"sprites/{index}.png").convert_alpha()

"""
# Fonction pour ajuster la taille du fond
def resize_window(new_size):

    global screen, bg_day#,img
    screen = pygame.display.set_mode(new_size, HWSURFACE | DOUBLEBUF | RESIZABLE)
    #screen.blit(pygame.transform.scale(img, new_size), (0, 0))
    screen.blit(pygame.transform.scale(bg_day, new_size), (0, 0))
    pygame.display.flip()

"""

# affectation des variables de jeu

ground_scroll = 0
scroll_speed = 5
flying = False
game_over = False
pipe_gap = 200
pipe_frequency = 1500 # millisecondes
last_pipe = pygame.time.get_ticks() - pipe_frequency
pass_pipe = False
game_score = 0
number = 0

# création des différentes classes 

""" 
Si vous voulez savoir ce qu'est la classe Sprite, c'est pas forcément nécéssaire
mais je pose ça là, sachant qu'il faut déjà savoir ce qu'est une classe avant d'aller voir là bas
https://fr.wikibooks.org/wiki/Pygame/Introduction_au_module_Sprite
"""

class Bird(pygame.sprite.Sprite):
    def __init__(self, x, y):
        pygame.sprite.Sprite.__init__(self)
        self.images = []
        self.index = 0
        self.counter = 0
        for num in range(1,4):
            img = pygame.image.load(f"sprites/yellowbird-{num}RZ.png").convert_alpha()
            self.images.append(img)
        # la redimension de l'image créer un rectangle noir autour de l'image donc je passe pour le moment
        self.image = self.images[self.index]
        self.rect = self.image.get_rect()
        self.rect.center = [x, y]
        self.velocity = 0
        self.clicked = False

    def update(self):
        
        # gravité
        if flying == True:
            self.velocity += 0.5
            if self.rect.bottom < 1024:
                self.rect.y +=  int(self.velocity)
            if self.velocity >= 8:
                self.velocity = 8
        if game_over == False:
            # saut
            if pygame.mouse.get_pressed()[0] == 1 and self.clicked == False:
                self.clicked = True
                self.velocity = -10
            if not pygame.mouse.get_pressed()[0] == 1 :
                self.clicked = False
            #actualise l'animation
            self.counter += 1
            flap_cooldown = 5
            if self.counter > flap_cooldown:
                self.counter = 0
                self.index += 1
                if self.index >= len(self.images):
                    self.index = 0

                self.image = self.images[self.index]
            # tourner l'oiseau
            self.image = pygame.transform.rotate(self.images[self.index],-self.velocity * 2)
        else:
            self.image = pygame.transform.rotate(self.images[self.index],-90)

class Pipe(pygame.sprite.Sprite):
    def __init__(self, x, y, position):
        pygame.sprite.Sprite.__init__(self)    
        self.image = pygame.image.load("sprites/pipe-greenRZ.png").convert_alpha()
        self.rect = self.image.get_rect()
        # position 1 pour le sprite haut position -1 pour le sprite bas
        if position == 1:
            self.image = pygame.transform.flip(self.image, False, True)
            self.rect.bottomleft = [x,y - int(pipe_gap / 2)]
        elif position == -1:
            self.rect.topleft = [x,y + int(pipe_gap / 2)]

    def update(self):
        if game_over == False:
            self.rect.x -= scroll_speed
        if self.rect.right < 0:
            self.kill()

bird_group = pygame.sprite.Group()
pipe_group = pygame.sprite.Group()


flappy = Bird(100, int(screen_height / 2))
bird_group.add(flappy)

# Boucle du jeu


run = True

while run:




    # empeche la boucle de se répéter trop rapidement
    clock.tick(fps)

    # dessine l'arrière plan
    screen.blit(bg_day,(0,0) )

    if flying == False and game_over != True:
        screen.blit(message,(99,249))

    # créer l'oiseau
    bird_group.draw(screen)
    bird_group.update()

    pipe_group.draw(screen)
    pipe_group.update()

    # dessine le sol
    screen.blit(base,(ground_scroll,1024) )

    # check le score

    if len(pipe_group) > 0:
        if bird_group.sprites()[0].rect.left > pipe_group.sprites()[0].rect.left\
            and bird_group.sprites()[0].rect.left < pipe_group.sprites()[0].rect.right\
            and pass_pipe == False:
            pass_pipe = True
        if pass_pipe == True:
            if bird_group.sprites()[0].rect.left > pipe_group.sprites()[0].rect.right:
                pass_pipe = False
                game_score += 1

    # vérifier les collisions
    if pygame.sprite.groupcollide(bird_group, pipe_group, False, False) or flappy.rect.top < 0:
        game_over = True

    # check si l'oiseau touche le sol
    
    if flappy.rect.bottom >= 1024:
        game_over = True
        flying = False

    # affichage du game_score

    number = list(str(game_score))
    for img in range(len(number)):
        
        screen.blit(number_png(number[img]),(img * 24,0))

    if game_over == False and flying == True:

        # génère de nouveaux tuyaux

        time_now = pygame.time.get_ticks()
        if time_now - last_pipe > pipe_frequency:
            pipe_height = randint(-115,116)
            btm_pipe = Pipe(screen_widht,int(screen_height/2) + pipe_height, -1)
            top_pipe = Pipe(screen_widht,int(screen_height/2) + pipe_height, 1)
            pipe_group.add(btm_pipe, top_pipe)
            last_pipe = time_now
            

        ground_scroll -= scroll_speed

    if ground_scroll <= -48:
        ground_scroll = 0


    for event in pygame.event.get():
        if event.type == QUIT:
            run = False
        if event.type == pygame.MOUSEBUTTONDOWN and flying == False and game_over == False:
            flying = True
        """
        elif event.type == VIDEORESIZE:
            resize_window(event.dict['size'])
        """
    pygame.display.update()

pygame.quit()







"""


# début de code rudimentaire

'''

Projet Flappy Bird 
Code cahier des charge classique 

Définir 3 zones pour chaque obstacle, Haut, milieu ou bas.
A chaque obstacle, la zone de passage est choisie aléatoirement
L'oiseau tente un passage aléatoire en volant au niveau d'une de ces 3 zones
Si cela concorde, l'oiseau passe et le jeu continu sinon le jeu s'arrête 
50pts si 4 obstacles franchis (score max)
Sinon 3 pts par obstacle franchi
'''


# coding: utf-8

from random import randint 


bas = 1
milieu = 2
haut = 3 

oiseau = 0 

obstacle = 0

pts = 0 

nbre_obstacle = 0 

#partie de l'ordinateur

while nbre_obstacle < 4 and oiseau == obstacle:
    oiseau = randint(1,3)
    obstacle = randint(1,3)
    if oiseau == obstacle :
        pts += 3 
        nbre_obstacle +=1 

if nbre_obstacle == 4 :
    pts = 50 

print (f"L'oiseau a dépassé {nbre_obstacle} obstacles")
print (f"Cela donne {pts} points ")


#élément necessaire à l'ouverture du csv

characters_tab = []
with open("Characters.csv", mode='r', encoding='utf-8') as f:
    lines = f.readlines()
    key_line = lines[0].strip()
    keys = key_line.split(";")
    for line in lines[1:]:
        line = line.strip()
        
        values = line.split(';')
        dico = {}
        for i in range(len(keys)):
            dico[keys[i]] = values[i]
        characters_tab.append(dico)
    
for character in characters_tab:
    if character['Name'] == 'Rose Granger-Weasley':
        print(f"La maison de Rose Granger-Weasley est {character['House']}")    
    if character['Name'] == 'Seamus Finnigan':
        print(f"Le patronus de Seamus Finnigan est {character['Patronus']}")
    if character['Name'] == 'Hermione Jean Granger':
        print(f"La couleur des cheveux d'Hermione Jean Granger est {character['Hair colour']}")


# Création 'un index par personnage, c'est à dire un dictionnaire de dictionnaires.

characters_index = {character['Name'] : character for character in characters_tab}

# Affichage de l'index pour vérification

print(characters_index)

# Utilisation de cet index pour répondre aux questions précédentes
print(f"\nLa maison de Rose Granger-Weasley est {characters_index['Rose Granger-Weasley']['House']}")    
print(f"Le patronus de Seamus Finnigan est {characters_index['Seamus Finnigan']['Patronus']}")
print(f"La couleur des cheveux d'Hermione Jean Granger est {characters_index['Hermione Jean Granger']['Hair colour']}")

"""
