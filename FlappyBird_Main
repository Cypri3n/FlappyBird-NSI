'''
Projet Flappy Bird 

On fait jouer automatiquement dix fois 
chaque personnage d'Harry Potter au jeu suivant :
Flappy Bird
A chaque obstacle, la zone de passage est choisie aléatoirement entre 3 zones
L'oiseau tente un passage aléatoire en volant au niveau d'une de ces 3 zones
Si cela concorde, l'oiseau passe et le jeu continu sinon le jeu s'arrête 
50pts si 4 obstacles franchis (score max)
Sinon 3 pts par obstacle franchi
L'oiseau peut passer au max 4 obstacles
On fait une moyenne des 10 résultats pour chaque personnage 
qu'on affiche dans l'ordre décroissant


Auteurs :
Cyprien Venard
Paul Di Prizio
Odon Prouille

Version :


Date de dernière révision :


Adresse Github: 
https://github.com/Cypri3n/FlappyBird-NSI/tree/main

'''
# coding: utf-8

#import des modules
from random import randint
import pygame



#définition des constantes
oiseau = 0 

obstacle = 0

pts = 0 

nbre_obstacle = 0 


#définitionn des fonctions dans l'ordre d'utlilisation

def partie(x):
    '''
    Joue la partie et implémente le score # A REVOIR

    Entrée : un dico
    Sortie : un dico
    '''
    oiseau = 0 
    obstacle = 0
    pts = 0
    nbre_obstacle = 0
    
    
    while nbre_obstacle < 4 and oiseau == obstacle:
        oiseau = randint(1,3)
        obstacle = randint(1,3)
        if oiseau == obstacle :
            pts += 3 
            nbre_obstacle +=1 
        if nbre_obstacle == 4:
            pts = 50
    x.append(pts)
    return x
oiseau = 0
obstacle = 0




#Début du programmme

#ouvre le csv et le transforme en liste contenant des dicos
characters_liste_de_dico = []

with open("Characters.csv", mode='r', encoding='utf-8') as f:
    lignes = f.readlines()
    cles_de_ligne = lignes[0].strip()
    keys = cles_de_ligne.split(";")
    for line in lignes[1:]:
        line = line.strip()
        valeurs = line.split(';')
        dico = {}
        for i in range(len(keys)):
            dico[keys[i]] = valeurs[i]
        characters_liste_de_dico.append(dico)
        for z in range (23):
            dico.pop

#transforme en liste de liste de toutes les caractéristiques
listes_de_liste_characters = [list(dico.values()) for dico in characters_liste_de_dico]



#transforme en une liste de chaque nom dans une liste
liste_nom = [[liste[1]] for liste in listes_de_liste_characters]


#transforme en un dico de chaque nom dans une liste
dico_chaque_nom = [{liste[1]} for liste in listes_de_liste_characters]



resultats = []
liste_scores = []


     
for i in range(len(dico_chaque_nom)) :
    for _ in range (10):  
        resultats = partie(liste_nom[i])
    liste_scores.append(resultats)

#print(liste_scores)


somme = 0

liste_scores_finaux = []

# somme des scores pour un score total

for x in range(len(liste_scores)):
    for i in range (1, len(liste_scores[x])):
        somme += liste_scores[x][i]       
        if i == len(liste_scores[x])-1:
            somme = somme / (len(liste_scores[x]) - 1)
            liste_scores_finaux.append([liste_scores[x][0]])
            liste_scores_finaux[x].append(somme)
            somme = 0


# tri de la liste

for x in range (1, len(liste_scores_finaux)):
    while liste_scores_finaux[x][1] < liste_scores_finaux[x - 1][1] and x > 0:
        liste_scores_finaux[x], liste_scores_finaux[x - 1] = liste_scores_finaux[x - 1], liste_scores_finaux[x]
        x -= 1

#classement par ordre décroissant
liste_scores_finaux.reverse()

print(liste_scores_finaux)




"""

PYGAME

"""








#Début du programme principal

from pygame.locals import QUIT, VIDEORESIZE, HWSURFACE, DOUBLEBUF, RESIZABLE
#from pygame.sprite import _Group

pygame.init()

clock = pygame.time.Clock()
fps = 60

# Configurer l'écran

screen_widht = 576
screen_height = 1248

# changer les valeurs de l'écran par des variables de préférence
screen = pygame.display.set_mode((screen_widht, screen_height), HWSURFACE | DOUBLEBUF | RESIZABLE)
pygame.display.set_caption("Flappy Bird")

# Images

# l'image avec un RZ (resize) veut tire que je l'ai mise à 200% de sa taille, il suffit de l'enlever
# pour se retrouver avec le format de base

bg_day = pygame.image.load("sprites/background-dayRZ.png").convert()
base = pygame.image.load("sprites/baseRZ.png").convert()
message = pygame.image.load("sprites/messageRZ.png").convert_alpha()
restart = pygame.image.load("sprites/restartRZ.png").convert()
ranking = pygame.image.load("sprites/rankingRZ.png").convert_alpha()
gm_img = pygame.image.load("sprites/gameoverRZ.png").convert_alpha()

def number_png(index):
    return pygame.image.load(f"sprites/{index}.png").convert_alpha()


"""
# Fonction pour ajuster la taille du fond
def resize_window(new_size):

    global screen, bg_day#,img
    screen = pygame.display.set_mode(new_size, HWSURFACE | DOUBLEBUF | RESIZABLE)
    #screen.blit(pygame.transform.scale(img, new_size), (0, 0))
    screen.blit(pygame.transform.scale(bg_day, new_size), (0, 0))
    pygame.display.flip()

"""

# affectation des variables de jeu

ground_scroll = 0
scroll_speed = 5
flying = False
game_over = False
pipe_gap = 200
pipe_frequency = 1500 # millisecondes
last_pipe = pygame.time.get_ticks() - pipe_frequency
pass_pipe = False
game_score = 0
number = 0
leaderboard = False
text_font = pygame.font.SysFont("Arial", 20)
Y = 0

# création des différentes classes 

""" 
Si vous voulez savoir ce qu'est la classe Sprite, c'est pas forcément nécéssaire
mais je pose ça là, sachant qu'il faut déjà savoir ce qu'est une classe avant d'aller voir là bas
https://fr.wikibooks.org/wiki/Pygame/Introduction_au_module_Sprite
"""


def reset_game():
    pipe_group.empty()
    flappy.rect.x = 100
    flappy.rect.y = int(screen_height / 2)
    game_score = 0
    return game_score

def draw_text(text, font, color, x, y):
    img = font.render(text, True, color)
    screen.blit(img, (x, y))


class Bird(pygame.sprite.Sprite):
    def __init__(self, x, y):
        pygame.sprite.Sprite.__init__(self)
        self.images = []
        self.index = 0
        self.counter = 0
        for num in range(1,4):
            img = pygame.image.load(f"sprites/yellowbird-{num}RZ.png").convert_alpha()
            self.images.append(img)
        # la redimension de l'image créer un rectangle noir autour de l'image donc je passe pour le moment
        self.image = self.images[self.index]
        self.rect = self.image.get_rect()
        self.rect.center = [x, y]
        self.velocity = 0
        self.clicked = False

    def update(self):
        
        # gravité
        if flying == True:
            self.velocity += 0.5
            if self.rect.bottom < 1024:
                self.rect.y +=  int(self.velocity)
            if self.velocity >= 8:
                self.velocity = 8
        if game_over == False:
            # saut
            if pygame.mouse.get_pressed()[0] == 1 and self.clicked == False:
                self.clicked = True
                self.velocity = -10
            if not pygame.mouse.get_pressed()[0] == 1 :
                self.clicked = False
            #actualise l'animation
            self.counter += 1
            flap_cooldown = 5
            if self.counter > flap_cooldown:
                self.counter = 0
                self.index += 1
                if self.index >= len(self.images):
                    self.index = 0

                self.image = self.images[self.index]
            # tourner l'oiseau
            self.image = pygame.transform.rotate(self.images[self.index],-self.velocity * 2)
        else:
            self.image = pygame.transform.rotate(self.images[self.index],-90)

class Pipe(pygame.sprite.Sprite):
    def __init__(self, x, y, position):
        pygame.sprite.Sprite.__init__(self)    
        self.image = pygame.image.load("sprites/pipe-greenRZ.png").convert_alpha()
        self.rect = self.image.get_rect()
        # position 1 pour le sprite haut position -1 pour le sprite bas
        if position == 1:
            self.image = pygame.transform.flip(self.image, False, True)
            self.rect.bottomleft = [x,y - int(pipe_gap / 2)]
        elif position == -1:
            self.rect.topleft = [x,y + int(pipe_gap / 2)]

    def update(self):
        if game_over == False:
            self.rect.x -= scroll_speed
        if self.rect.right < 0:
            self.kill()

class Button():
    def __init__(self, x, y, image):
        self.image = image
        self.rect = self.image.get_rect()
        self.rect.topleft = (x,y)

    def draw(self):

        action = False

        # récupérer la position du curseur
        pos = pygame.mouse.get_pos()
        # vérifie si la souris passe sur le boutton

        if self.rect.collidepoint(pos):
            if pygame.mouse.get_pressed()[0] == 1:
                action = True
        # affiche l'image
        screen.blit(self.image, (self.rect.x, self.rect.y))

        return action

bird_group = pygame.sprite.Group()
pipe_group = pygame.sprite.Group()

restart_button = Button(screen_widht / 2 - 120, screen_height / 2 + 350, restart)
ranking_button = Button(screen_widht - 120, screen_height - 74, ranking)

flappy = Bird(100, int(screen_height / 2))
bird_group.add(flappy)

# Boucle du jeu


run = True

while run:




    # empeche la boucle de se répéter trop rapidement
    clock.tick(fps)

    # dessine l'arrière plan
    screen.blit(bg_day,(0,0) )

    if flying == False and game_over != True:
        screen.blit(message,(99,249))

    # créer l'oiseau
    bird_group.draw(screen)
    bird_group.update()

    pipe_group.draw(screen)
    pipe_group.update()

    # dessine le sol
    screen.blit(base,(ground_scroll,1024) )

    # check le score

    if len(pipe_group) > 0:
        if bird_group.sprites()[0].rect.left > pipe_group.sprites()[0].rect.left\
            and bird_group.sprites()[0].rect.left < pipe_group.sprites()[0].rect.right\
            and pass_pipe == False:
            pass_pipe = True
        if pass_pipe == True:
            if bird_group.sprites()[0].rect.left > pipe_group.sprites()[0].rect.right:
                pass_pipe = False
                game_score += 1

    # vérifier les collisions
    if pygame.sprite.groupcollide(bird_group, pipe_group, False, False) or flappy.rect.top < 0:
        game_over = True

    # check si l'oiseau touche le sol
    
    if flappy.rect.bottom >= 1024:
        game_over = True
        flying = False

    # affichage du game_score

    number = list(str(game_score))
    for img in range(len(number)):
        
        screen.blit(number_png(number[img]),(img * 24,0))

    if game_over == False and flying == True:

        # génère de nouveaux tuyaux

        time_now = pygame.time.get_ticks()
        if time_now - last_pipe > pipe_frequency:
            pipe_height = randint(-115,116)
            btm_pipe = Pipe(screen_widht,int(screen_height/2) + pipe_height, -1)
            top_pipe = Pipe(screen_widht,int(screen_height/2) + pipe_height, 1)
            pipe_group.add(btm_pipe, top_pipe)
            last_pipe = time_now
            

        ground_scroll -= scroll_speed

    if ground_scroll <= -48:
        ground_scroll = 0



    # check pour un game over et reset
    if game_over == True:

        screen.blit(gm_img,(screen_widht / 2 - 192 , 150))

        if ranking_button.draw() == True:
            leaderboard = True
        if leaderboard == True:
            screen.fill((0,0,0))

            for i in range(len(liste_scores_finaux)):
                Y += 20
                if Y > 1024:
                    Y = 1024
                
                
                draw_text(f"Nom : {liste_scores_finaux[i][0]} ; Score : {liste_scores_finaux[i][1]}",text_font, (254,254,254), 100, Y)
                if i == len(liste_scores_finaux):
                    Y= 0
                print(Y)
#                for event in pygame.event.get():
#                    if event.type == pygame.KEYDOWN:
#                        if event.key == pygame.K_DOWN:
#                            Y -= 20
#                            draw_text(f"Nom : {liste_scores_finaux[i][0]} ; Score : {liste_scores_finaux[i][1]}",text_font, (254,254,254), 100, Y)
#                            print (Y)
#                    else:
#                        ptint('r')

                         
        if restart_button.draw() == True:
            game_over = False
            leaderboard = False
            score = reset_game()
        

    for event in pygame.event.get():
        if event.type == QUIT:
            run = False
        if event.type == pygame.MOUSEBUTTONDOWN and flying == False and game_over == False:
            flying = True
        """
        elif event.type == VIDEORESIZE:
            resize_window(event.dict['size'])
        """

    pygame.display.flip()
    pygame.display.update()

pygame.quit()

